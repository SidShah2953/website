---
import { getCollection } from 'astro:content';
import ContentListLayout from '@/layouts/ContentListLayout.astro';
import ContentCard from '@/components/ContentCard.astro';
import { estimateReadingTime } from '@/utils/estimateReadingTime';

const blogPosts = (await getCollection('blog'))
  .filter(p => !p.data.isDraft)
  .sort((a, b) => b.data.publishedAt.getTime() - a.data.publishedAt.getTime());

// Inject reading time (if not stored yet)
const enriched = blogPosts.map(p => {
  if (!p.data.readingTimeMinutes) {
    const stats = estimateReadingTime(p.body);
    return { ...p, data: { ...p.data, readingTimeMinutes: stats.minutes } };
  }
  return p;
});

// Collect all unique tags
const allTags = [...new Set(enriched.flatMap(p => p.data.tags))].sort();

// Pass all posts to client-side for filtering
const postsData = enriched.map(p => ({
  slug: p.slug,
  title: p.data.title,
  description: p.data.description,
  publishedAt: p.data.publishedAt.toISOString(),
  tags: p.data.tags
}));
---

<ContentListLayout
  title="Blog"
  pageTitle="Blog | Siddhant Shah"
  description="Long-form posts, experiments & deeper dives into finance, tech, and quantitative analysis."
  allTags={allTags}
  enableTagFilter={true}
  contentType="blog"
>
  {enriched.map(post => (
    <ContentCard
      type="blog"
      slug={post.slug}
      title={post.data.title}
      description={post.data.description}
      publishedAt={post.data.publishedAt}
      tags={post.data.tags}
    />
  ))}
</ContentListLayout>

<script is:inline define:vars={{ postsData }}>
  const posts = postsData;
  const container = document.getElementById('content-container');
  const tagMessage = document.getElementById('tag-message');
  const noPostsMessage = document.getElementById('no-posts-message');
  const tagFilters = document.querySelectorAll('.tag-filter');

  function renderPosts(filtered, selectedTag) {
    if (filtered.length === 0) {
      container.classList.add('hidden');
      noPostsMessage.classList.remove('hidden');
      return;
    }

    container.classList.remove('hidden');
    noPostsMessage.classList.add('hidden');

    container.innerHTML = filtered.map(post => {
      const date = new Date(post.publishedAt).toLocaleDateString('en-GB', { day: '2-digit', month: '2-digit', year: 'numeric' }).replace(/\//g, '/');
      return `
        <a class="content-card content-card--blog group glass-card-hover p-6 flex flex-col gap-3 relative overflow-hidden" href="/blog/${post.slug}" data-tags="${post.tags.join(',')}">
          <div class="absolute inset-0 bg-gradient-to-br from-finance-cyan/0 to-finance-blue/0 group-hover:from-finance-cyan/5 group-hover:to-finance-blue/5 transition-all duration-300 rounded-2xl"></div>
          <div class="relative z-10">
            <div class="flex w-full items-start justify-between gap-4 flex-wrap">
              <h2 class="font-semibold text-white group-hover:text-finance-cyan transition-colors leading-tight flex-1 text-xl">${post.title}</h2>
              <div class="flex flex-row items-center gap-3 text-sm text-neutral-400 shrink-0">
                <time datetime="${post.publishedAt}">${date}</time>
                <svg width="20" height="20" viewBox="0 0 18 18" fill="none" class="transition-all duration-300 group-hover:translate-x-1 group-hover:translate-y-[-2px] opacity-60 group-hover:opacity-100">
                  <path d="M5.25 12.75L12.75 5.25" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path>
                  <path d="M5.25 5.25H12.75V12.75" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path>
                </svg>
              </div>
            </div>
            <p class="text-neutral-300 leading-relaxed line-clamp-2 mt-2">${post.description}</p>
          </div>
        </a>
      `;
    }).join('');

    if (selectedTag) {
      tagMessage.innerHTML = `Showing posts tagged with <strong class="text-neutral-200">${selectedTag}</strong>`;
      tagMessage.classList.remove('hidden');
    } else {
      tagMessage.classList.add('hidden');
    }
  }

  function filterByTag(tag) {
    const filtered = tag ? posts.filter(p => p.tags.includes(tag)) : posts;

    // Update URL without reload
    const url = new URL(window.location);
    if (tag) {
      url.searchParams.set('tag', tag);
    } else {
      url.searchParams.delete('tag');
    }
    window.history.pushState({}, '', url);

    // Update button states
    tagFilters.forEach(btn => {
      const btnTag = btn.dataset.tag;
      if (btnTag === tag) {
        btn.classList.remove('bg-neutral-800', 'text-neutral-400');
        btn.classList.add('bg-neutral-700', 'text-neutral-100');
      } else {
        btn.classList.remove('bg-neutral-700', 'text-neutral-100');
        btn.classList.add('bg-neutral-800', 'text-neutral-400', 'hover:bg-neutral-700');
      }
    });

    renderPosts(filtered, tag);
  }

  // Set up click handlers
  tagFilters.forEach(btn => {
    btn.addEventListener('click', () => {
      const tag = btn.dataset.tag;
      filterByTag(tag);
    });
  });

  // Check URL on load
  const urlParams = new URLSearchParams(window.location.search);
  const initialTag = urlParams.get('tag');
  if (initialTag) {
    filterByTag(initialTag);
  }
</script>
